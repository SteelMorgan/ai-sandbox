#!/usr/bin/env bash
# Configures Codex CLI (v0.105+) for the current user.
#
# Reads non-secret settings from env vars (injected via .devcontainer/.env):
#   CC_HELPER_BASE_URL — base URL of the OpenAI-compatible server
#   CODEX_MODEL        — default model name
#
# Reads API token from Docker secret:
#   /run/secrets/cc_api_key
#
# Writes:
#   ~/.codex/config.toml
#   ~/.codex/.env
#   ~/bin/codex-safe.sh
set -euo pipefail

CODEX_DIR="${HOME}/.codex"
mkdir -p "${CODEX_DIR}"

BASE_URL="${CC_HELPER_BASE_URL:-}"
MODEL="${CODEX_MODEL:-}"

if [[ -z "${BASE_URL}" ]]; then
  echo "[codex-bootstrap] CC_HELPER_BASE_URL is not set — skipping Codex config." >&2
  exit 0
fi

if [[ -z "${MODEL}" ]]; then
  echo "[codex-bootstrap] CODEX_MODEL is not set — skipping Codex config." >&2
  exit 0
fi

SECRET_FILE="/run/secrets/cc_api_key"
API_KEY=""
if [[ -f "${SECRET_FILE}" ]]; then
  API_KEY="$(cat "${SECRET_FILE}")"
fi

if [[ -z "${API_KEY}" ]]; then
  echo "[codex-bootstrap] WARNING: /run/secrets/cc_api_key is empty — Codex will start without an API key." >&2
fi

# Codex CLI >=0.105 reads TOML config.
rm -f "${CODEX_DIR}/config.yaml"
cat > "${CODEX_DIR}/config.toml" << TOML
# Auto-generated by .devcontainer/codex-bootstrap.sh — do not edit manually.

model = "${MODEL}"
model_provider = "myserver"
approval_policy = "on-request"

[model_providers.myserver]
name = "MyServer"
base_url = "${BASE_URL}"
env_key = "CODEX_MY_SERVER_API_KEY"
wire_api = "responses"
TOML

printf "CODEX_MY_SERVER_API_KEY=%s\n" "${API_KEY}" > "${CODEX_DIR}/.env"
chmod 0600 "${CODEX_DIR}/.env"

echo "[codex-bootstrap] ~/.codex/config.toml written (model_provider=myserver, model=${MODEL}, base_url=${BASE_URL})"

WRAPPER_DIR="${HOME}/bin"
CODEX_WRAPPER="${WRAPPER_DIR}/codex-safe.sh"
mkdir -p "${WRAPPER_DIR}"

cat > "${CODEX_WRAPPER}" << 'WRAPPER'
#!/usr/bin/env bash
set -euo pipefail

if ! command -v codex >/dev/null 2>&1; then
  echo "codex command not found in PATH" >&2
  exit 127
fi

CODEX_ENV_FILE="${HOME}/.codex/.env"
if [ -f "${CODEX_ENV_FILE}" ]; then
  while IFS='=' read -r key val; do
    case "${key}" in
      ''|\#*) continue ;;
    esac
    export "${key}=${val}"
  done < "${CODEX_ENV_FILE}"
fi

exec codex "$@"
WRAPPER

chmod +x "${CODEX_WRAPPER}"
echo "[codex-bootstrap] ${CODEX_WRAPPER} created."

CLAUDE_WRAPPER_ORIG="/usr/local/share/agent-sandbox/tools/claude-safe.sh"
CLAUDE_WRAPPER="${WRAPPER_DIR}/claude-safe.sh"
BASHRC="${HOME}/.bashrc"
add_alias() {
  local name="$1"
  local target="$2"
  local rc_file="$3"
  local prefix="$4"
  [ -f "${rc_file}" ] || touch "${rc_file}"
  if grep -qF "alias ${name}=" "${rc_file}" 2>/dev/null; then
    echo "[${prefix}] alias '${name}' already exists in ${rc_file} — skipping."
    return 0
  fi
  printf '\n# Added by .devcontainer/codex-bootstrap.sh\nalias %s="%s"\n' "${name}" "${target}" >> "${rc_file}"
  echo "[${prefix}] alias '${name}' added to ${rc_file}."
}

if [ -f "${CLAUDE_WRAPPER_ORIG}" ]; then
  chmod +x "${CLAUDE_WRAPPER_ORIG}" 2>/dev/null || true
  ln -sfn "${CLAUDE_WRAPPER_ORIG}" "${CLAUDE_WRAPPER}"
  add_alias "cc" "${CLAUDE_WRAPPER}" "${BASHRC}" "claude-bootstrap"
  add_alias "сс" "${CLAUDE_WRAPPER}" "${BASHRC}" "claude-bootstrap"
else
  echo "[codex-bootstrap] claude-safe.sh not found at ${CLAUDE_WRAPPER_ORIG} — aliases 'cc'/'сс' skipped."
fi

add_alias "cx" "${CODEX_WRAPPER}" "${BASHRC}" "codex-bootstrap"
add_alias "сч" "${CODEX_WRAPPER}" "${BASHRC}" "codex-bootstrap"

echo "[codex-bootstrap] Done. Aliases active after: source ~/.bashrc"
